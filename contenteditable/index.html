<!DOCTYPE html>
<html lang="en">
<head>
  <title>Trumbowyg v3 - Content Editable</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #ddd;
      font-size: 16px;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    [contenteditable] {
      height: 75%;
      padding: 25px;
      font-family: Helvetica, Arial, sans-serif;
      background: #eee;
      border-bottom: 3px solid #ccc;
      overflow: auto;
    }

    #result {
      padding: 25px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div contenteditable="true">
    <div>
      <p>Lorem <del>ipsum <strong>d<em>o</em>lor</strong></del> <em>sit</em> amet.</p>
      <p>And <strong>blah <em>or</em></strong> nah.</p>
      <div>
        Salut
        <img src="img.svg" alt="Some JavaScript logo" width="20px">
      </div>
      <ul>
        <li>Item 1</li>
        <li>Second item</li>
        <li>List in list
          <ul>
            <li>Third li</li>
            <li>Fourth Item</li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
  <div id="result"></div>

  <script>
    const contenteditable = document.querySelector('[contenteditable]')
    contenteditable.innerHTML = contenteditable.innerHTML.replace(/>\s{2,}</g, '><')
    const showContentEditableHtml = () => {
      document.getElementById('result').innerHTML = contenteditable.innerHTML.replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;")
    }
    contenteditable.addEventListener('input', showContentEditableHtml)
    showContentEditableHtml()

    const SELECTABLE_TAGS = ['img', 'embed', 'input', 'hr']

    function isOrphanSelectableNode(el) {
      return SELECTABLE_TAGS.indexOf(el.tagName.toLowerCase()) !== -1
    }

    function getTextNodes(el) {
      if (el.nodeType === Node.TEXT_NODE) {
        return [el]
      }

      // Replace orphan nodes by text-like node with a space to keep 1 index reserved for that element
      if (isOrphanSelectableNode(el)) {
        return [{textContent: ' '}]
      }

      return Array.from(el.childNodes).reduce(function (acc, childNode) {
        if (childNode.nodeType !== Node.TEXT_NODE) {
          return acc.concat(getTextNodes(childNode))
        }

        acc.push(childNode)
        return acc
      }, [])
    }

    function cleanTextNode(textNode) {
      return textNode.textContent.replace(/(^ {2,})|( {2,}$)/g, '')
    }

    function getNodeOffset(rootEl, el, offset, isElIncluded) {
      if (el === rootEl) {
        return offset
      }

      const addedIndexIfIncluded = isElIncluded ? 1 : 0

      const childNodes = Array.from(el.parentNode.childNodes)
      const previousNodes = childNodes.slice(0, childNodes.indexOf(el) + addedIndexIfIncluded)
      const previousNodesText = previousNodes.reduce((acc, node) => acc.concat(getTextNodes(node)), []).map(cleanTextNode)

      offset = offset + previousNodesText.reduce((acc, nodeText) => acc + nodeText.length, 0)

      return getNodeOffset(rootEl, el.parentNode, offset, false)
    }

    function cleanRangeBoundary(rangeContainer, rangeOffset) {
      let isRangeContainerIncluded = false

      if (rangeContainer.nodeType !== Node.TEXT_NODE) {
        if (rangeContainer.childNodes.length !== rangeOffset) {
          rangeContainer = rangeContainer.childNodes[rangeOffset]
        } else {
          isRangeContainerIncluded = true
        }

        rangeOffset = 0
      }

      return {
        rangeContainer,
        rangeOffset,
        isRangeContainerIncluded,
      }
    }

    function convertRangeToAbsoluteIndexes(rootEl, range) {
      const {
        rangeContainer: startContainer,
        rangeOffset: startOffset,
        isRangeContainerIncluded: isStartContainerIncluded,
      } = cleanRangeBoundary(range.startContainer, range.startOffset)

      const {
        rangeContainer: endContainer,
        rangeOffset: endOffset,
        isRangeContainerIncluded: isEndContainerIncluded,
      } = cleanRangeBoundary(range.endContainer, range.endOffset)

      const startIndex = getNodeOffset(rootEl, startContainer, startOffset, isStartContainerIncluded)
      const endIndex = getNodeOffset(rootEl, endContainer, endOffset, isEndContainerIncluded)

      return [startIndex, endIndex]
    }


    let lastRange = null
    document.addEventListener('selectionchange', () => {
      const selection = document.getSelection()

      if (selection.type === 'Range') {
        const range = selection.getRangeAt(0)
        console.log(range)
        if (lastRange !== range && !range.collapsed) {
          const [absRangeStart, absRangeEnd] = convertRangeToAbsoluteIndexes(contenteditable, range)
          console.log('Absolute Range', absRangeStart, absRangeEnd)

          let textNodes = getTextNodes(contenteditable)
          let cleanedTextNodesContent = textNodes.map(function (textNode) { return cleanTextNode(textNode) })
          console.log('Selected text:', cleanedTextNodesContent.join('').substr(absRangeStart, absRangeEnd - absRangeStart))

          lastRange = range
        }
      }
    })


    function getNodeForIndex(rootEl, absoluteIndex) {
      let node = null
      let index = absoluteIndex
      let childNodes = Array.from(rootEl.childNodes)

      let childNode = null
      while (!node && childNodes.length > 0) {
        childNode = childNodes.shift()
        if (childNode.nodeType === Node.TEXT_NODE) {
          let cleanedTextNodeLength = cleanTextNode(childNode).length
          index -= cleanedTextNodeLength

          if (index <= 0) {
            node = childNode
            index += cleanedTextNodeLength
          }
        } else if (isOrphanSelectableNode(childNode)) {
          index -= 1

          if (index <= 0) {
            node = childNode
            index = 0
          }
        } else {
          let nodeText = childNode.innerText

          // Find only if index is in text range
          if (index - nodeText.length <= 0) {
            [node, index] = getNodeForIndex(childNode, index)
          } else {
            index -= nodeText.length
          }
        }
      }

      return [node, index]
    }

    function setSelection(absStartIndex, absEndIndex) {
      let [startNode, startIndex] = getNodeForIndex(contenteditable, absStartIndex)

      if (!absEndIndex) {
        document.getSelection().removeAllRanges()
        document.getSelection().setPosition(startNode, startIndex)
        return
      }

      let [endNode, endIndex] = getNodeForIndex(contenteditable, absEndIndex)

      let range = document.createRange()
      range.setStart(startNode, startIndex)
      range.setEnd(endNode, endIndex)
      document.getSelection().removeAllRanges()
      document.getSelection().addRange(range)
    }

    // RESET
    const oldHtml = contenteditable.innerHTML
    contenteditable.innerHTML = ''
    contenteditable.innerHTML = oldHtml

    // SET SELECTION 5, 16 (m ipsum dol)
    setSelection(5, 16)
  </script>
</body>
</html>
